<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>崁燈洗牆效果模擬器</title>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Three.js (使用較舊版本，OrbitControls 會自動附加到 THREE) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <!-- Babel Standalone -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    html, body, #root {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    #root > div {
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useRef, useEffect, useState, useCallback } = React;

    const LightingSimulator = () => {
      const canvasRef = useRef(null);
      const sceneRef = useRef(null);
      const rendererRef = useRef(null);
      const cameraRef = useRef(null);
      const controlsRef = useRef(null);
      const spotLightRef = useRef(null);
      const spotLightHelperRef = useRef(null);
      const animationRef = useRef(null);

      // 燈光參數
      const [beamAngle, setBeamAngle] = useState(30); // 放射角度 (度)
      const [tiltAngle, setTiltAngle] = useState(45); // 與天花板夾角 (度)
      const [wallDistance, setWallDistance] = useState(0.5); // 與牆面距離 (米)
      const [softness, setSoftness] = useState(0.5); // 均光效果 (0=銳利, 1=柔和)
      const [lightIntensity, setLightIntensity] = useState(100); // 燈光強度
      const [lightColor, setLightColor] = useState('#fff5e6'); // 燈光顏色
      const [showHelper, setShowHelper] = useState(true); // 顯示輔助線
      const [showSecondLight, setShowSecondLight] = useState(false); // 第二盞燈
      const [lightSpacing, setLightSpacing] = useState(1.0); // 燈間距
      const [wallColor, setWallColor] = useState('#9e9e9e'); // 牆面顏色 (水泥灰)
      const [showGrid, setShowGrid] = useState(true); // 顯示牆面網格
      const [wallHeight, setWallHeight] = useState(3); // 牆壁高度 (米)，預設 300cm

      // 從 URL 讀取初始參數
      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        if (params.has('ba')) setBeamAngle(Number(params.get('ba')));
        if (params.has('ta')) setTiltAngle(Number(params.get('ta')));
        if (params.has('wd')) setWallDistance(Number(params.get('wd')));
        if (params.has('wh')) setWallHeight(Number(params.get('wh')));
        if (params.has('sf')) setSoftness(Number(params.get('sf')));
        if (params.has('li')) setLightIntensity(Number(params.get('li')));
        if (params.has('lc')) setLightColor(decodeURIComponent(params.get('lc')));
        if (params.has('sh')) setShowHelper(params.get('sh') === '1');
        if (params.has('sl')) setShowSecondLight(params.get('sl') === '1');
        if (params.has('ls')) setLightSpacing(Number(params.get('ls')));
        if (params.has('wc')) setWallColor(decodeURIComponent(params.get('wc')));
        if (params.has('sg')) setShowGrid(params.get('sg') === '1');
      }, []);

      // 同步參數到 URL
      useEffect(() => {
        const params = new URLSearchParams();
        params.set('ba', beamAngle);
        params.set('ta', tiltAngle);
        params.set('wd', wallDistance);
        params.set('wh', wallHeight);
        params.set('sf', softness);
        params.set('li', lightIntensity);
        params.set('lc', encodeURIComponent(lightColor));
        params.set('sh', showHelper ? '1' : '0');
        params.set('sl', showSecondLight ? '1' : '0');
        params.set('ls', lightSpacing);
        params.set('wc', encodeURIComponent(wallColor));
        params.set('sg', showGrid ? '1' : '0');

        const newUrl = `${window.location.pathname}?${params.toString()}`;
        window.history.replaceState({}, '', newUrl);
      }, [beamAngle, tiltAngle, wallDistance, wallHeight, softness, lightIntensity, lightColor, showHelper, showSecondLight, lightSpacing, wallColor, showGrid]);

      // 視角切換
      const switchView = useCallback((viewName) => {
        if (!cameraRef.current || !controlsRef.current) return;
        const camera = cameraRef.current;
        const controls = controlsRef.current;

        const views = {
          perspective: { pos: [4, 2, 4], target: [0, 1, 0] },
          front: { pos: [0, 1.5, 5], target: [0, 1.5, -3] },
          top: { pos: [0, 6, 0], target: [0, 0, -1] },
          side: { pos: [6, 1.5, 0], target: [0, 1.5, -3] },
        };

        const view = views[viewName];
        if (view) {
          camera.position.set(...view.pos);
          controls.target.set(...view.target);
          controls.update();
        }
      }, []);

      // Three.js 初始化
      useEffect(() => {
        const canvas = canvasRef.current;
        const container = canvas.parentElement;
        const width = container.clientWidth;
        const height = container.clientHeight;

        // 場景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        sceneRef.current = scene;

        // 相機
        const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100);
        camera.position.set(4, 2, 4);
        camera.lookAt(0, 1, 0);
        cameraRef.current = camera;

        // 渲染器
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.physicallyCorrectLights = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        rendererRef.current = renderer;

        // 控制器
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 1, 0);
        controlsRef.current = controls;

        // 房間尺寸
        const roomWidth = 6;
        const roomHeight = 3;
        const roomDepth = 6;

        // 材質
        const wallMaterial = new THREE.MeshStandardMaterial({
          color: 0x9e9e9e, // 水泥灰
          roughness: 0.9,
          metalness: 0,
        });
        sceneRef.current.wallMaterial = wallMaterial;

        const floorMaterial = new THREE.MeshStandardMaterial({
          color: 0x8b7355,
          roughness: 0.8,
          metalness: 0,
        });

        const ceilingMaterial = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          roughness: 0.9,
          metalness: 0,
        });

        // 地板
        const floor = new THREE.Mesh(
          new THREE.PlaneGeometry(roomWidth, roomDepth),
          floorMaterial
        );
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // 天花板
        const ceiling = new THREE.Mesh(
          new THREE.PlaneGeometry(roomWidth, roomDepth),
          ceilingMaterial
        );
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.y = roomHeight;
        ceiling.receiveShadow = true;
        scene.add(ceiling);

        // 後牆 (主要洗牆目標)
        const backWall = new THREE.Mesh(
          new THREE.PlaneGeometry(roomWidth, roomHeight),
          wallMaterial
        );
        backWall.position.set(0, roomHeight / 2, -roomDepth / 2);
        backWall.receiveShadow = true;
        scene.add(backWall);

        // 左牆
        const leftWall = new THREE.Mesh(
          new THREE.PlaneGeometry(roomDepth, roomHeight),
          wallMaterial
        );
        leftWall.position.set(-roomWidth / 2, roomHeight / 2, 0);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.receiveShadow = true;
        scene.add(leftWall);

        // 右牆
        const rightWall = new THREE.Mesh(
          new THREE.PlaneGeometry(roomDepth, roomHeight),
          wallMaterial
        );
        rightWall.position.set(roomWidth / 2, roomHeight / 2, 0);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.receiveShadow = true;
        scene.add(rightWall);

        // 儲存牆壁和天花板參考
        sceneRef.current.ceiling = ceiling;
        sceneRef.current.backWall = backWall;
        sceneRef.current.leftWall = leftWall;
        sceneRef.current.rightWall = rightWall;
        sceneRef.current.roomWidth = roomWidth;
        sceneRef.current.ceilingMaterial = ceilingMaterial;

        // 牆面網格輔助線
        const createWallGrid = (width, height, position, rotation) => {
          const gridGroup = new THREE.Group();
          const gridMaterial = new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.5 });
          const step = 0.5; // 50cm 間距

          // 水平線
          for (let y = 0; y <= height; y += step) {
            const points = [new THREE.Vector3(-width / 2, y - height / 2, 0.01), new THREE.Vector3(width / 2, y - height / 2, 0.01)];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, gridMaterial);
            gridGroup.add(line);
          }
          // 垂直線
          for (let x = -width / 2; x <= width / 2; x += step) {
            const points = [new THREE.Vector3(x, -height / 2, 0.01), new THREE.Vector3(x, height / 2, 0.01)];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, gridMaterial);
            gridGroup.add(line);
          }

          gridGroup.position.copy(position);
          if (rotation) {
            gridGroup.rotation.y = rotation;
          }
          gridGroup.visible = false;
          return gridGroup;
        };

        const backWallGrid = createWallGrid(roomWidth, roomHeight, new THREE.Vector3(0, roomHeight / 2, -roomDepth / 2));
        scene.add(backWallGrid);
        const leftWallGrid = createWallGrid(roomDepth, roomHeight, new THREE.Vector3(-roomWidth / 2, roomHeight / 2, 0), Math.PI / 2);
        scene.add(leftWallGrid);
        const rightWallGrid = createWallGrid(roomDepth, roomHeight, new THREE.Vector3(roomWidth / 2, roomHeight / 2, 0), -Math.PI / 2);
        scene.add(rightWallGrid);

        sceneRef.current.grids = { backWallGrid, leftWallGrid, rightWallGrid };

        // 環境光 (提高強度讓牆面顏色可辨識)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        // 聚光燈
        const spotLight = new THREE.SpotLight(0xfff5e6, 100);
        spotLight.position.set(0, roomHeight - 0.05, -roomDepth / 2 + 0.5);
        spotLight.angle = THREE.MathUtils.degToRad(30);
        spotLight.penumbra = 0.5;
        spotLight.decay = 2;
        spotLight.distance = 10;
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = 1024;
        spotLight.shadow.mapSize.height = 1024;
        spotLight.shadow.camera.near = 0.1;
        spotLight.shadow.camera.far = 10;
        scene.add(spotLight);
        spotLightRef.current = spotLight;

        // 聚光燈目標
        const targetObject = new THREE.Object3D();
        targetObject.position.set(0, 0, -roomDepth / 2);
        scene.add(targetObject);
        spotLight.target = targetObject;

        // 聚光燈輔助器
        const spotLightHelper = new THREE.SpotLightHelper(spotLight);
        scene.add(spotLightHelper);
        spotLightHelperRef.current = spotLightHelper;

        // 輔助光源群組（用於均光效果）
        const auxLights = [];
        for (let i = 0; i < 4; i++) {
          const auxLight = new THREE.SpotLight(0xfff5e6, 0);
          auxLight.penumbra = 1;
          auxLight.decay = 1.5;
          auxLight.distance = 12;
          auxLight.castShadow = false; // 不投射陰影，節省效能
          auxLight.visible = false;
          scene.add(auxLight);

          // 輔助光源目標
          const auxTarget = new THREE.Object3D();
          scene.add(auxTarget);
          auxLight.target = auxTarget;

          auxLights.push({ light: auxLight, target: auxTarget });
        }
        sceneRef.current.auxLights = auxLights;

        // 燈具模型 (崁燈外殼)
        const lightFixture = new THREE.Group();
        const outerRing = new THREE.Mesh(
          new THREE.TorusGeometry(0.08, 0.015, 16, 32),
          new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.2 })
        );
        outerRing.rotation.x = Math.PI / 2;
        lightFixture.add(outerRing);
        const innerCone = new THREE.Mesh(
          new THREE.ConeGeometry(0.06, 0.1, 32, 1, true),
          new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5, roughness: 0.5, side: THREE.DoubleSide })
        );
        innerCone.position.y = -0.05;
        lightFixture.add(innerCone);
        lightFixture.position.copy(spotLight.position);
        scene.add(lightFixture);

        // 第二盞燈
        const spotLight2 = new THREE.SpotLight(0xfff5e6, 100);
        spotLight2.angle = THREE.MathUtils.degToRad(30);
        spotLight2.penumbra = 0.5;
        spotLight2.decay = 2;
        spotLight2.distance = 10;
        spotLight2.castShadow = true;
        spotLight2.visible = false;
        scene.add(spotLight2);

        const targetObject2 = new THREE.Object3D();
        scene.add(targetObject2);
        spotLight2.target = targetObject2;

        const lightFixture2 = lightFixture.clone();
        lightFixture2.visible = false;
        scene.add(lightFixture2);

        // 第二盞燈的輔助光源群組
        const auxLights2 = [];
        for (let i = 0; i < 4; i++) {
          const auxLight2 = new THREE.SpotLight(0xfff5e6, 0);
          auxLight2.penumbra = 1;
          auxLight2.decay = 1.5;
          auxLight2.distance = 12;
          auxLight2.castShadow = false;
          auxLight2.visible = false;
          scene.add(auxLight2);

          const auxTarget2 = new THREE.Object3D();
          scene.add(auxTarget2);
          auxLight2.target = auxTarget2;

          auxLights2.push({ light: auxLight2, target: auxTarget2 });
        }

        // 儲存到 ref
        sceneRef.current.spotLight2 = spotLight2;
        sceneRef.current.targetObject2 = targetObject2;
        sceneRef.current.lightFixture = lightFixture;
        sceneRef.current.lightFixture2 = lightFixture2;
        sceneRef.current.auxLights2 = auxLights2;
        sceneRef.current.targetObject = targetObject;
        sceneRef.current.roomHeight = roomHeight;
        sceneRef.current.roomDepth = roomDepth;

        // 動畫循環
        const animate = () => {
          animationRef.current = requestAnimationFrame(animate);
          controls.update();
          if (spotLightHelperRef.current) {
            spotLightHelperRef.current.update();
          }
          renderer.render(scene, camera);
        };
        animate();

        // 響應式調整
        const handleResize = () => {
          const width = container.clientWidth;
          const height = container.clientHeight;
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize(width, height, false);
        };
        window.addEventListener('resize', handleResize);
        // 延遲初始化尺寸，確保 CSS 已套用
        setTimeout(handleResize, 100);

        return () => {
          window.removeEventListener('resize', handleResize);
          cancelAnimationFrame(animationRef.current);
          renderer.dispose();
        };
      }, []);

      // 更新燈光參數
      useEffect(() => {
        if (!spotLightRef.current || !sceneRef.current) return;

        const spotLight = spotLightRef.current;
        const scene = sceneRef.current;
        // 直接使用 wallHeight state，確保燈的位置與牆壁高度同步
        const roomHeight = wallHeight;
        const roomDepth = scene.roomDepth;

        // 計算燈的位置
        const lightY = roomHeight - 0.05;
        const lightZ = -roomDepth / 2 + wallDistance;

        spotLight.position.set(0, lightY, lightZ);

        // 計算目標點位置 (根據夾角)
        // 與天花板夾角：0°=水平照射牆面, 90°=垂直向下
        const tiltRad = THREE.MathUtils.degToRad(tiltAngle);
        const targetY = lightY - Math.sin(tiltRad) * 3;
        const targetZ = lightZ - Math.cos(tiltRad) * 3;
        scene.targetObject.position.set(0, targetY, targetZ);

        // 更新燈光參數
        const baseAngle = THREE.MathUtils.degToRad(beamAngle / 2);
        spotLight.angle = baseAngle;
        // 主光源 penumbra：softness 0~0.33 時從 0 到 1
        spotLight.penumbra = Math.min(softness * 3, 1);
        spotLight.decay = 2;
        spotLight.distance = 10;
        // 主光源強度隨 softness 增加而降低（讓輔助光源補償）
        const mainIntensityRatio = 1 - softness * 0.4; // 1 -> 0.6
        spotLight.intensity = lightIntensity * mainIntensityRatio;
        spotLight.color.set(lightColor);

        // 更新輔助光源（用於均光效果）
        const auxStartThreshold = 0.2; // 從 20% 開始加入輔助光源
        if (scene.auxLights) {
          scene.auxLights.forEach((aux, i) => {
            // 每個輔助光源在不同的 softness 值開始啟用
            const activationPoint = auxStartThreshold + i * 0.2; // 0.2, 0.4, 0.6, 0.8
            const auxStrength = Math.max(0, (softness - activationPoint) / (1 - activationPoint));

            aux.light.visible = softness > activationPoint;

            if (aux.light.visible) {
              // 角度比主光源略大
              aux.light.angle = baseAngle * (1.15 + i * 0.1);
              aux.light.intensity = lightIntensity * auxStrength * 0.12;
              aux.light.color.set(lightColor);
              aux.light.position.copy(spotLight.position);
              aux.target.position.set(0, targetY, targetZ);
            }
          });
        }

        // 更新燈具位置
        if (scene.lightFixture) {
          scene.lightFixture.position.copy(spotLight.position);
        }

        // 更新輔助器
        if (spotLightHelperRef.current) {
          spotLightHelperRef.current.visible = showHelper;
          spotLightHelperRef.current.update();
        }

        // 第二盞燈
        if (scene.spotLight2) {
          scene.spotLight2.visible = showSecondLight;
          scene.lightFixture2.visible = showSecondLight;

          if (showSecondLight) {
            scene.spotLight2.position.set(lightSpacing, lightY, lightZ);
            scene.spotLight2.angle = baseAngle;
            scene.spotLight2.penumbra = Math.min(softness * 3, 1);
            scene.spotLight2.decay = 2;
            scene.spotLight2.distance = 10;
            scene.spotLight2.intensity = lightIntensity * mainIntensityRatio;
            scene.spotLight2.color.set(lightColor);

            scene.targetObject2.position.set(lightSpacing, targetY, targetZ);
            scene.lightFixture2.position.copy(scene.spotLight2.position);

            // 第二盞燈的輔助光源
            if (scene.auxLights2) {
              scene.auxLights2.forEach((aux, i) => {
                const activationPoint = auxStartThreshold + i * 0.2;
                const auxStrength = Math.max(0, (softness - activationPoint) / (1 - activationPoint));

                aux.light.visible = showSecondLight && softness > activationPoint;

                if (aux.light.visible) {
                  aux.light.angle = baseAngle * (1.15 + i * 0.1);
                  aux.light.intensity = lightIntensity * auxStrength * 0.12;
                  aux.light.color.set(lightColor);
                  aux.light.position.copy(scene.spotLight2.position);
                  aux.target.position.set(lightSpacing, targetY, targetZ);
                }
              });
            }
          } else {
            // 隱藏第二盞燈的輔助光源
            if (scene.auxLights2) {
              scene.auxLights2.forEach((aux) => {
                aux.light.visible = false;
              });
            }
          }
        }
      }, [beamAngle, tiltAngle, wallDistance, softness, lightIntensity, lightColor, showHelper, showSecondLight, lightSpacing, wallHeight]);

      // 更新牆面顏色
      useEffect(() => {
        if (!sceneRef.current || !sceneRef.current.wallMaterial) return;
        sceneRef.current.wallMaterial.color.set(wallColor);
      }, [wallColor]);

      // 更新網格顯示
      useEffect(() => {
        if (!sceneRef.current || !sceneRef.current.grids) return;
        const { backWallGrid, leftWallGrid, rightWallGrid } = sceneRef.current.grids;
        backWallGrid.visible = showGrid;
        leftWallGrid.visible = showGrid;
        rightWallGrid.visible = showGrid;
      }, [showGrid]);

      // 更新牆壁高度
      useEffect(() => {
        if (!sceneRef.current) return;
        const scene = sceneRef.current;
        const { ceiling, backWall, leftWall, rightWall, roomWidth, roomDepth, wallMaterial, grids } = scene;

        if (!ceiling || !backWall || !leftWall || !rightWall) return;

        // 更新天花板位置
        ceiling.position.y = wallHeight;

        // 更新後牆
        backWall.geometry.dispose();
        backWall.geometry = new THREE.PlaneGeometry(roomWidth, wallHeight);
        backWall.position.set(0, wallHeight / 2, -roomDepth / 2);

        // 更新左牆
        leftWall.geometry.dispose();
        leftWall.geometry = new THREE.PlaneGeometry(roomDepth, wallHeight);
        leftWall.position.set(-roomWidth / 2, wallHeight / 2, 0);

        // 更新右牆
        rightWall.geometry.dispose();
        rightWall.geometry = new THREE.PlaneGeometry(roomDepth, wallHeight);
        rightWall.position.set(roomWidth / 2, wallHeight / 2, 0);

        // 更新 roomHeight 參考值
        scene.roomHeight = wallHeight;

        // 更新網格輔助線
        if (grids) {
          const { backWallGrid, leftWallGrid, rightWallGrid } = grids;

          // 重新建立網格
          const updateGrid = (gridGroup, width, height, position, rotation) => {
            gridGroup.clear();
            const gridMaterial = new THREE.LineBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.5 });
            const step = 0.5;

            for (let y = 0; y <= height; y += step) {
              const points = [new THREE.Vector3(-width / 2, y - height / 2, 0.01), new THREE.Vector3(width / 2, y - height / 2, 0.01)];
              const geometry = new THREE.BufferGeometry().setFromPoints(points);
              const line = new THREE.Line(geometry, gridMaterial);
              gridGroup.add(line);
            }
            for (let x = -width / 2; x <= width / 2; x += step) {
              const points = [new THREE.Vector3(x, -height / 2, 0.01), new THREE.Vector3(x, height / 2, 0.01)];
              const geometry = new THREE.BufferGeometry().setFromPoints(points);
              const line = new THREE.Line(geometry, gridMaterial);
              gridGroup.add(line);
            }
            gridGroup.position.copy(position);
            if (rotation) gridGroup.rotation.y = rotation;
          };

          updateGrid(backWallGrid, roomWidth, wallHeight, new THREE.Vector3(0, wallHeight / 2, -roomDepth / 2));
          updateGrid(leftWallGrid, roomDepth, wallHeight, new THREE.Vector3(-roomWidth / 2, wallHeight / 2, 0), Math.PI / 2);
          updateGrid(rightWallGrid, roomDepth, wallHeight, new THREE.Vector3(roomWidth / 2, wallHeight / 2, 0), -Math.PI / 2);
        }
      }, [wallHeight]);

      // 預設值
      const presets = {
        narrowBeam: { beamAngle: 15, tiltAngle: 30, wallDistance: 0.3, softness: 0.2 },
        wideFlood: { beamAngle: 60, tiltAngle: 60, wallDistance: 0.8, softness: 0.8 },
        wallWash: { beamAngle: 40, tiltAngle: 45, wallDistance: 0.5, softness: 0.6 },
        accent: { beamAngle: 20, tiltAngle: 35, wallDistance: 0.4, softness: 0.3 },
      };

      const applyPreset = (preset) => {
        setBeamAngle(preset.beamAngle);
        setTiltAngle(preset.tiltAngle);
        setWallDistance(preset.wallDistance);
        setSoftness(preset.softness);
      };

      return (
        <div className="flex h-screen bg-gray-900 text-white">
          {/* 3D 視圖 */}
          <div className="flex-1 relative">
            <canvas ref={canvasRef} className="w-full h-full" />

            {/* 說明與視角切換 */}
            <div className="absolute top-4 left-4 bg-black/60 backdrop-blur-sm rounded-lg p-3 text-sm">
              <p className="text-gray-300 mb-2">拖曳旋轉 | 滾輪縮放 | 右鍵平移</p>
              <div className="flex gap-1">
                <button onClick={() => switchView('perspective')} className="px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded text-xs">立體</button>
                <button onClick={() => switchView('front')} className="px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded text-xs">正視</button>
                <button onClick={() => switchView('top')} className="px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded text-xs">俯視</button>
                <button onClick={() => switchView('side')} className="px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded text-xs">側視</button>
              </div>
            </div>

            {/* 當前數值顯示 */}
            <div className="absolute bottom-4 left-4 bg-black/60 backdrop-blur-sm rounded-lg p-4">
              <div className="grid grid-cols-2 gap-x-6 gap-y-1 text-sm">
                <span className="text-gray-400">放射角度:</span>
                <span className="text-yellow-400 font-mono">{beamAngle}°</span>
                <span className="text-gray-400">傾斜角度:</span>
                <span className="text-yellow-400 font-mono">{tiltAngle}°</span>
                <span className="text-gray-400">離牆距離:</span>
                <span className="text-yellow-400 font-mono">{wallDistance.toFixed(2)}m</span>
                <span className="text-gray-400">牆壁高度:</span>
                <span className="text-yellow-400 font-mono">{(wallHeight * 100).toFixed(0)}cm</span>
                <span className="text-gray-400">柔光程度:</span>
                <span className="text-yellow-400 font-mono">{(softness * 100).toFixed(0)}%</span>
              </div>
            </div>
          </div>

          {/* 控制面板 */}
          <div className="w-80 bg-gray-800 p-4 overflow-y-auto">
            <h1 className="text-xl font-bold mb-4 text-center">崁燈洗牆模擬器</h1>

            {/* 預設 */}
            <div className="mb-6">
              <h2 className="text-sm font-semibold text-gray-400 mb-2">快速預設</h2>
              <div className="grid grid-cols-2 gap-2">
                <button
                  onClick={() => applyPreset(presets.narrowBeam)}
                  className="px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded text-sm transition"
                >
                  窄光束
                </button>
                <button
                  onClick={() => applyPreset(presets.wideFlood)}
                  className="px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded text-sm transition"
                >
                  寬泛光
                </button>
                <button
                  onClick={() => applyPreset(presets.wallWash)}
                  className="px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded text-sm transition"
                >
                  洗牆效果
                </button>
                <button
                  onClick={() => applyPreset(presets.accent)}
                  className="px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded text-sm transition"
                >
                  重點照明
                </button>
              </div>
            </div>

            <div className="space-y-5">
              {/* 放射角度 */}
              <div>
                <div className="flex justify-between mb-1">
                  <label className="text-sm font-medium">放射角度 (Beam Angle)</label>
                  <span className="text-yellow-400 font-mono text-sm">{beamAngle}°</span>
                </div>
                <input
                  type="range"
                  min="10"
                  max="120"
                  value={beamAngle}
                  onChange={(e) => setBeamAngle(Number(e.target.value))}
                  className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-yellow-500"
                />
                <p className="text-xs text-gray-500 mt-1">控制光束的發散範圍</p>
              </div>

              {/* 傾斜角度 */}
              <div>
                <div className="flex justify-between mb-1">
                  <label className="text-sm font-medium">與天花板夾角 (Tilt)</label>
                  <span className="text-yellow-400 font-mono text-sm">{tiltAngle}°</span>
                </div>
                <input
                  type="range"
                  min="0"
                  max="90"
                  value={tiltAngle}
                  onChange={(e) => setTiltAngle(Number(e.target.value))}
                  className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-yellow-500"
                />
                <p className="text-xs text-gray-500 mt-1">0°=水平照射牆面, 90°=垂直向下</p>
              </div>

              {/* 離牆距離 */}
              <div>
                <div className="flex justify-between mb-1">
                  <label className="text-sm font-medium">離牆距離</label>
                  <span className="text-yellow-400 font-mono text-sm">{wallDistance.toFixed(2)}m</span>
                </div>
                <input
                  type="range"
                  min="0.1"
                  max="1.5"
                  step="0.05"
                  value={wallDistance}
                  onChange={(e) => setWallDistance(Number(e.target.value))}
                  className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-yellow-500"
                />
                <p className="text-xs text-gray-500 mt-1">燈具中心到牆面的距離</p>
              </div>

              {/* 牆壁高度 */}
              <div>
                <div className="flex justify-between mb-1">
                  <label className="text-sm font-medium">牆壁高度</label>
                  <span className="text-yellow-400 font-mono text-sm">{(wallHeight * 100).toFixed(0)}cm</span>
                </div>
                <input
                  type="range"
                  min="2"
                  max="5"
                  step="0.1"
                  value={wallHeight}
                  onChange={(e) => setWallHeight(Number(e.target.value))}
                  className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-yellow-500"
                />
                <p className="text-xs text-gray-500 mt-1">房間高度 (200cm - 500cm)</p>
              </div>

              {/* 柔光程度 */}
              <div>
                <div className="flex justify-between mb-1">
                  <label className="text-sm font-medium">均光效果</label>
                  <span className="text-yellow-400 font-mono text-sm">{(softness * 100).toFixed(0)}%</span>
                </div>
                <input
                  type="range"
                  min="0"
                  max="1"
                  step="0.01"
                  value={softness}
                  onChange={(e) => setSoftness(Number(e.target.value))}
                  className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-yellow-500"
                />
                <p className="text-xs text-gray-500 mt-1">調整光線邊緣的柔和程度</p>
              </div>

              {/* 燈光強度 */}
              <div>
                <div className="flex justify-between mb-1">
                  <label className="text-sm font-medium">燈光強度</label>
                  <span className="text-yellow-400 font-mono text-sm">{lightIntensity}</span>
                </div>
                <input
                  type="range"
                  min="10"
                  max="300"
                  value={lightIntensity}
                  onChange={(e) => setLightIntensity(Number(e.target.value))}
                  className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-yellow-500"
                />
              </div>

              {/* 色溫 */}
              <div>
                <div className="flex justify-between mb-1">
                  <label className="text-sm font-medium">燈光顏色</label>
                </div>
                <div className="flex gap-2">
                  <button
                    onClick={() => setLightColor('#fff5e6')}
                    className={`flex-1 py-2 rounded text-sm ${lightColor === '#fff5e6' ? 'ring-2 ring-yellow-500' : ''}`}
                    style={{ background: '#fff5e6', color: '#333' }}
                  >
                    暖白 3000K
                  </button>
                  <button
                    onClick={() => setLightColor('#ffffff')}
                    className={`flex-1 py-2 rounded text-sm ${lightColor === '#ffffff' ? 'ring-2 ring-yellow-500' : ''}`}
                    style={{ background: '#ffffff', color: '#333' }}
                  >
                    自然白 4000K
                  </button>
                  <button
                    onClick={() => setLightColor('#f0f5ff')}
                    className={`flex-1 py-2 rounded text-sm ${lightColor === '#f0f5ff' ? 'ring-2 ring-yellow-500' : ''}`}
                    style={{ background: '#f0f5ff', color: '#333' }}
                  >
                    冷白 6000K
                  </button>
                </div>
              </div>

              {/* 牆面顏色 */}
              <div>
                <div className="flex justify-between mb-1">
                  <label className="text-sm font-medium">牆面顏色</label>
                </div>
                <div className="flex gap-2 flex-wrap">
                  <button
                    onClick={() => setWallColor('#9e9e9e')}
                    className={`flex-1 py-2 rounded text-xs ${wallColor === '#9e9e9e' ? 'ring-2 ring-yellow-500' : ''}`}
                    style={{ background: '#9e9e9e', color: '#fff' }}
                  >
                    水泥灰
                  </button>
                  <button
                    onClick={() => setWallColor('#f5f5f5')}
                    className={`flex-1 py-2 rounded text-xs ${wallColor === '#f5f5f5' ? 'ring-2 ring-yellow-500' : ''}`}
                    style={{ background: '#f5f5f5', color: '#333' }}
                  >
                    白色
                  </button>
                  <button
                    onClick={() => setWallColor('#e8dcc8')}
                    className={`flex-1 py-2 rounded text-xs ${wallColor === '#e8dcc8' ? 'ring-2 ring-yellow-500' : ''}`}
                    style={{ background: '#e8dcc8', color: '#333' }}
                  >
                    米白
                  </button>
                  <button
                    onClick={() => setWallColor('#d4c4a8')}
                    className={`flex-1 py-2 rounded text-xs ${wallColor === '#d4c4a8' ? 'ring-2 ring-yellow-500' : ''}`}
                    style={{ background: '#d4c4a8', color: '#333' }}
                  >
                    卡其
                  </button>
                </div>
                <div className="mt-2 flex items-center gap-2">
                  <input
                    type="color"
                    value={wallColor}
                    onChange={(e) => setWallColor(e.target.value)}
                    className="w-8 h-8 rounded cursor-pointer"
                  />
                  <span className="text-xs text-gray-400">自訂顏色</span>
                </div>
              </div>

              <hr className="border-gray-700" />

              {/* 多燈設定 */}
              <div>
                <label className="flex items-center gap-2 cursor-pointer">
                  <input
                    type="checkbox"
                    checked={showSecondLight}
                    onChange={(e) => setShowSecondLight(e.target.checked)}
                    className="w-4 h-4 accent-yellow-500"
                  />
                  <span className="text-sm font-medium">啟用第二盞燈</span>
                </label>

                {showSecondLight && (
                  <div className="mt-3">
                    <div className="flex justify-between mb-1">
                      <label className="text-sm">燈間距</label>
                      <span className="text-yellow-400 font-mono text-sm">{lightSpacing.toFixed(2)}m</span>
                    </div>
                    <input
                      type="range"
                      min="0.5"
                      max="2"
                      step="0.1"
                      value={lightSpacing}
                      onChange={(e) => setLightSpacing(Number(e.target.value))}
                      className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-yellow-500"
                    />
                  </div>
                )}
              </div>

              {/* 輔助線 */}
              <div>
                <label className="flex items-center gap-2 cursor-pointer">
                  <input
                    type="checkbox"
                    checked={showHelper}
                    onChange={(e) => setShowHelper(e.target.checked)}
                    className="w-4 h-4 accent-yellow-500"
                  />
                  <span className="text-sm font-medium">顯示光錐輔助線</span>
                </label>
              </div>

              {/* 網格 */}
              <div>
                <label className="flex items-center gap-2 cursor-pointer">
                  <input
                    type="checkbox"
                    checked={showGrid}
                    onChange={(e) => setShowGrid(e.target.checked)}
                    className="w-4 h-4 accent-yellow-500"
                  />
                  <span className="text-sm font-medium">顯示牆面網格 (50cm)</span>
                </label>
              </div>
            </div>

            {/* 設計建議 */}
            <div className="mt-6 p-3 bg-gray-700/50 rounded-lg">
              <h3 className="text-sm font-semibold text-yellow-400 mb-2">設計建議</h3>
              <ul className="text-xs text-gray-300 space-y-1">
                <li>• 洗牆效果建議離牆 30-50cm</li>
                <li>• 均勻洗牆角度約 40-60°</li>
                <li>• 重點照明使用窄角 15-25°</li>
                <li>• 柔光 &gt;50% 可減少眩光</li>
              </ul>
            </div>

            {/* 計算結果 */}
            <div className="mt-4 p-3 bg-blue-900/30 rounded-lg">
              <h3 className="text-sm font-semibold text-blue-400 mb-2">光學計算</h3>
              <div className="text-xs text-gray-300 space-y-1">
                <p>光錐直徑 (地面): <span className="text-blue-300 font-mono">
                  {(2 * wallHeight * Math.tan(beamAngle * Math.PI / 360)).toFixed(2)}m
                </span></p>
                <p>牆面光斑高度: <span className="text-blue-300 font-mono">
                  {(wallHeight / Math.sin(tiltAngle * Math.PI / 180) * Math.tan(beamAngle * Math.PI / 360) * 2).toFixed(2)}m
                </span></p>
              </div>
            </div>
          </div>
        </div>
      );
    };

    // 渲染應用
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<LightingSimulator />);
  </script>
</body>
</html>
